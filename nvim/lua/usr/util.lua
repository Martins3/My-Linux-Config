-- deepseek 协助编写，获取文件名
local function get_file_path()
  local file_path = vim.api.nvim_eval("expand('%:p')")
  local buf = vim.api.nvim_create_buf(false, true) -- 非列表 buffer，可编辑

  -- 将 buffer 显示在一个新的窗口中
  vim.api.nvim_open_win(buf, true, {
    relative = "editor",
    width = 60,
    height = 1,
    row = 1,
    col = 1,
    style = "minimal",
    border = "single",
  })

  vim.api.nvim_buf_set_lines(buf, 0, -1, false, { file_path })
end

vim.api.nvim_create_user_command("GetFilePath", get_file_path, {})

vim.api.nvim_create_user_command("InsertUUID", function()
  local function generate_uuid()
    local template = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"
    return string.gsub(template, "[xy]", function(c)
      local v = (c == "x") and math.random(0, 15) or math.random(8, 11)
      return string.format("%x", v)
    end)
  end

  math.randomseed(os.time()) -- Seed the random number generator
  local uuid = generate_uuid()
  local formatted_uuid = "<!-- " .. uuid .. " -->"
  vim.api.nvim_put({ formatted_uuid }, "", false, true)
end, { desc = "insert a generated UUID as an HTML comment" })

-- generated by Qwen
local function close_hidden_buffers()
  local current_buf = vim.api.nvim_get_current_buf()

  local tabpages = vim.api.nvim_list_tabpages()
  local visible_buffers = {}

  for _, tab in ipairs(tabpages) do
    local wins = vim.api.nvim_tabpage_list_wins(tab)
    for _, win in ipairs(wins) do
      local buf = vim.api.nvim_win_get_buf(win)
      visible_buffers[buf] = true
    end
  end

  for _, buf in ipairs(vim.api.nvim_list_bufs()) do
    if buf == current_buf then
      goto skip
    end

    if visible_buffers[buf] then
      goto skip
    end

    if vim.api.nvim_get_option_value("buftype", { buf = buf }) == "terminal" then
      vim.notify("Buffer " .. buf .. " is a terminal, not closing", vim.log.levels.INFO)
      goto skip
    end

    if vim.api.nvim_get_option_value("modified", { buf = buf }) then
      vim.notify("Buffer " .. buf .. " is modified, not closing", vim.log.levels.WARN)
      goto skip
    end

    vim.api.nvim_buf_delete(buf, { force = false })

    ::skip::
  end
end

vim.keymap.set(
  "n",
  "<space>bc",
  close_hidden_buffers,
  { noremap = true, silent = true, desc = "close all hidden buffers" }
)

-- 拷贝， <leader> a ，然后粘贴
-- 会调用脚本，将 clipboard 中的 gdb backtrace 简化之后再粘贴出来
function ProcessClipboard()
  -- 获取剪贴板内容
  local clipboard_content = vim.fn.getreg("+")
  -- 检查剪贴板内容是否为空
  if clipboard_content == "" then
    print("Clipboard is empty!")
    return
  end

  -- 打开文件并写入剪贴板内容
  local tmp = "/tmp/martins3/trim.txt"
  local file = io.open(tmp, "w+")
  if file then
    local success, err = file:write(clipboard_content)
    if not success then
      print("Failed to write to file: " .. err)
      return
    end
    file:close()
  else
    print("Failed to open file: " .. tmp)
    return
  end

  local project = "/home/martins3/data/vn"
  local script_path = project .. "/code/qemu/trim.sh"
  if vim.fn.filereadable(script_path) == 1 then
    vim.fn.system(script_path)
  else
    print("Script not found: " .. script_path)
  end

  file = io.open(tmp, "r")
  if file then
    local file_content = file:read("*a") -- 读取整个文件内容
    -- 将文件内容写入剪贴板
    vim.fn.setreg("+", file_content)
    print(file_content)
    file:close()
  else
    print("Failed to read file: " .. tmp)
  end
  print("trim finished !")
end

-- 映射快捷键
vim.api.nvim_set_keymap("n", "<leader>a", ":lua ProcessClipboard()<CR>", { noremap = true, silent = true })
